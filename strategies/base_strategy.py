# hydrobot2/strategies/base_strategy.py

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any, Dict, Optional, Literal
import pandas as pd

from hydrobot2.utils.logger_setup import get_logger

# Get the application logger
log = get_logger()

# Define the possible actions a signal can represent
SignalAction = Literal["BUY", "SELL", "HOLD", "CLOSE"]
OrderType = Literal["MARKET", "LIMIT"] # Matching common exchange types

@dataclass
class Signal:
    """
    Represents a trading signal generated by a strategy.

    This object carries all the necessary information for the trading
    manager to decide whether and how to act on the strategy's decision.
    """
    action: SignalAction = "HOLD" # Default action is to do nothing
    symbol: Optional[str] = None  # e.g., 'BTC/USDT'
    price: Optional[float] = None # Target price for LIMIT orders, execution price hint for MARKET
    quantity: Optional[float] = None # Amount of base asset to trade
    order_type: OrderType = "LIMIT" # Default to LIMIT orders
    confidence: float = 0.5 # Strategy's confidence in this signal (0.0 to 1.0)
    stop_loss_price: Optional[float] = None # Suggested stop-loss level for the trade
    take_profit_price: Optional[float] = None # Suggested take-profit level
    strategy_name: str = "BaseStrategy" # Name of the strategy generating the signal
    meta: Dict[str, Any] = field(default_factory=dict) # Extra info (e.g., indicators, reasons)

    def __str__(self):
        """Provides a readable string representation of the signal."""
        details = f"{self.action} {self.quantity:.6f} {self.symbol}" if self.symbol and self.quantity else self.action
        if self.action not in ["HOLD", "CLOSE"]:
             details += f" @ {self.price:.2f}" if self.price else " (Market)"
        if self.confidence != 0.5:
             details += f" (Conf: {self.confidence:.2f})"
        if self.stop_loss_price:
            details += f" SL: {self.stop_loss_price:.2f}"
        if self.take_profit_price:
            details += f" TP: {self.take_profit_price:.2f}"
        return details


class Strategy(ABC):
    """
    Abstract Base Class for all trading strategies.

    Ensures that all strategies implement the necessary methods to interact
    with the main trading loop and strategy manager.
    """

    def __init__(self, strategy_config: Dict[str, Any], global_config: Any):
        """
        Initializes the base strategy.

        Args:
            strategy_config: Dictionary containing parameters specific to this strategy
                             (e.g., from the 'scalping_strategy' section in config.yaml).
            global_config: The main application configuration object (AppSettings),
                           providing access to trading settings, risk settings, etc.
        """
        self.strategy_name = self.__class__.__name__ # Get the name of the specific strategy class
        self.config = strategy_config
        self.global_config = global_config
        self.symbol = None # Will be set by the TradingManager usually
        log.info(f"Initialized strategy: {self.strategy_name}")
        log.debug(f"Strategy '{self.strategy_name}' config: {self.config}")

    def set_symbol(self, symbol: str):
        """Sets the specific symbol this instance of the strategy will trade."""
        self.symbol = symbol
        log.info(f"Strategy '{self.strategy_name}' assigned to symbol: {symbol}")


    @abstractmethod
    def on_market_update(self, market_data: Dict[str, Any]):
        """
        Called when new market data arrives for the symbol this strategy handles.

        This is where the strategy might update its internal state, indicators, etc.

        Args:
            market_data: A dictionary containing the latest market information.
                         The exact structure depends on the MarketDataStream implementation
                         (e.g., {'timestamp': ..., 'bids': [...], 'asks': [...], 'last_trade': ...}).
        """
        pass

    @abstractmethod
    def generate_signal(self, market_data: Dict[str, Any], model_prediction: Optional[Any] = None) -> Signal:
        """
        The core logic of the strategy. Analyzes market data (and optional
        model predictions) to decide on a trading action.

        Args:
            market_data: Latest market information for the strategy's symbol.
            model_prediction: Optional output from a predictive model (e.g., price
                              forecast, regime classification, confidence score).

        Returns:
            A Signal object indicating the desired action (BUY, SELL, HOLD, CLOSE).
        """
        pass

    def update_parameters(self, new_params: Dict[str, Any]):
        """
        Allows dynamic updates to strategy parameters (e.g., based on market regime changes).

        Args:
            new_params: A dictionary of parameters to update.
        """
        log.info(f"Updating parameters for strategy '{self.strategy_name}' for symbol {self.symbol}")
        for key, value in new_params.items():
            if hasattr(self.config, key): # Or check if key exists if config is dict
                log.debug(f"  Updating {key}: {getattr(self.config, key)} -> {value}")
                setattr(self.config, key, value) # Assumes config is an object like Pydantic model
                # If config is a dict: self.config[key] = value
            else:
                log.warning(f"  Attempted to update unknown parameter '{key}' for strategy '{self.strategy_name}'")
        # Optionally re-initialize or recalculate based on new params if needed

    def get_name(self) -> str:
        """Returns the name of the strategy."""
        return self.strategy_name